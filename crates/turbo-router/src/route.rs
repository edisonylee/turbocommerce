//! Route metadata and registration.

/// Metadata for a route, generated by the `#[page]` macro.
///
/// This struct is used at compile time to collect route information
/// for automatic router generation.
#[derive(Debug, Clone, Copy)]
pub struct RouteMeta {
    /// The URL path pattern (e.g., "/product/:id")
    pub path: &'static str,
    /// The component function name
    pub component_name: &'static str,
}

impl RouteMeta {
    /// Create new route metadata.
    pub const fn new(path: &'static str, component_name: &'static str) -> Self {
        Self {
            path,
            component_name,
        }
    }

    /// Check if this route has dynamic segments.
    pub fn is_dynamic(&self) -> bool {
        self.path.contains(':') || self.path.contains('*')
    }

    /// Get the dynamic segment names.
    pub fn dynamic_segments(&self) -> Vec<&str> {
        self.path
            .split('/')
            .filter_map(|segment| {
                segment
                    .strip_prefix(':')
                    .or_else(|| segment.strip_prefix('*'))
            })
            .collect()
    }
}

/// A collected route with its component.
#[derive(Debug, Clone)]
pub struct RouteEntry {
    /// Route path pattern
    pub path: String,
    /// Component name
    pub component: String,
    /// Priority for ordering (more specific routes first)
    pub priority: i32,
}

impl RouteEntry {
    /// Create a new route entry.
    pub fn new(path: impl Into<String>, component: impl Into<String>) -> Self {
        let path = path.into();
        let priority = Self::calculate_priority(&path);
        Self {
            path,
            component: component.into(),
            priority,
        }
    }

    /// Calculate route priority (higher = more specific = matched first).
    ///
    /// - Static segments: +10 each
    /// - Named parameters (:id): +5 each
    /// - Wildcards (*rest): +1 each
    /// - Root path: +100
    fn calculate_priority(path: &str) -> i32 {
        if path == "/" {
            return 100;
        }

        path.split('/')
            .filter(|s| !s.is_empty())
            .map(|segment| {
                if segment.starts_with('*') {
                    1 // Wildcard: lowest priority
                } else if segment.starts_with(':') {
                    5 // Named param: medium priority
                } else {
                    10 // Static: highest priority
                }
            })
            .sum()
    }
}

/// Route registry for collecting routes.
///
/// In a real implementation, this would use inventory or linkme
/// for automatic registration. For now, routes are registered manually.
#[derive(Debug, Default)]
pub struct RouteRegistry {
    routes: Vec<RouteEntry>,
}

impl RouteRegistry {
    /// Create a new empty registry.
    pub fn new() -> Self {
        Self::default()
    }

    /// Register a route.
    pub fn register(&mut self, path: impl Into<String>, component: impl Into<String>) {
        self.routes.push(RouteEntry::new(path, component));
    }

    /// Get all routes sorted by priority (most specific first).
    pub fn routes(&self) -> Vec<&RouteEntry> {
        let mut routes: Vec<_> = self.routes.iter().collect();
        routes.sort_by(|a, b| b.priority.cmp(&a.priority));
        routes
    }

    /// Get the number of registered routes.
    pub fn len(&self) -> usize {
        self.routes.len()
    }

    /// Check if registry is empty.
    pub fn is_empty(&self) -> bool {
        self.routes.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_route_priority() {
        let mut registry = RouteRegistry::new();

        registry.register("/", "Home");
        registry.register("/product", "ProductList");
        registry.register("/product/:id", "ProductDetail");
        registry.register("/product/:id/reviews", "ProductReviews");
        registry.register("/*any", "NotFound");

        let routes = registry.routes();

        // Root should be first (highest priority = 100)
        assert_eq!(routes[0].path, "/");
        // Longer paths have higher priority:
        // /product/:id/reviews = 10 + 5 + 10 = 25
        assert_eq!(routes[1].path, "/product/:id/reviews");
        // /product/:id = 10 + 5 = 15
        assert_eq!(routes[2].path, "/product/:id");
        // /product = 10
        assert_eq!(routes[3].path, "/product");
        // Wildcard last (priority = 1)
        assert_eq!(routes[4].path, "/*any");
    }

    #[test]
    fn test_route_meta() {
        let meta = RouteMeta::new("/product/:id", "ProductPage");

        assert!(meta.is_dynamic());
        assert_eq!(meta.dynamic_segments(), vec!["id"]);
    }

    #[test]
    fn test_static_route() {
        let meta = RouteMeta::new("/about", "AboutPage");

        assert!(!meta.is_dynamic());
        assert!(meta.dynamic_segments().is_empty());
    }
}
